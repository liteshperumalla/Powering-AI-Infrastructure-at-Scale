apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb
  namespace: infra-mind
  labels:
    app: mongodb
    component: database
    tier: production
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
        component: database
        tier: production
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9216"
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 999
        fsGroup: 999
      containers:
      - name: mongodb
        image: mongo:7.0
        ports:
        - containerPort: 27017
          name: mongodb
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: infra-mind-secrets
              key: MONGO_ROOT_USERNAME
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: infra-mind-secrets
              key: MONGO_ROOT_PASSWORD
        - name: MONGO_INITDB_DATABASE
          value: "infra_mind"
        # Production MongoDB configuration
        command:
        - mongod
        - --auth
        - --bind_ip_all
        - --port=27017
        - --dbpath=/data/db
        - --logpath=/var/log/mongodb/mongod.log
        - --logappend
        - --journal
        - --wiredTigerCacheSizeGB=1
        - --wiredTigerJournalCompressor=snappy
        - --wiredTigerCollectionBlockCompressor=snappy
        - --wiredTigerIndexPrefixCompression=true
        - --slowms=100
        - --profile=1
        - --maxConns=1000
        volumeMounts:
        - name: mongodb-storage
          mountPath: /data/db
        - name: mongodb-config
          mountPath: /etc/mongod.conf
          subPath: mongod.conf
        - name: mongodb-init
          mountPath: /docker-entrypoint-initdb.d
        - name: mongodb-logs
          mountPath: /var/log/mongodb
        - name: mongodb-ssl
          mountPath: /etc/ssl/mongodb
          readOnly: true
        resources:
          requests:
            memory: "2Gi"
            cpu: "500m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          exec:
            command:
            - mongosh
            - --username=$MONGO_INITDB_ROOT_USERNAME
            - --password=$MONGO_INITDB_ROOT_PASSWORD
            - --authenticationDatabase=admin
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - mongosh
            - --username=$MONGO_INITDB_ROOT_USERNAME
            - --password=$MONGO_INITDB_ROOT_PASSWORD
            - --authenticationDatabase=admin
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        startupProbe:
          exec:
            command:
            - mongosh
            - --username=$MONGO_INITDB_ROOT_USERNAME
            - --password=$MONGO_INITDB_ROOT_PASSWORD
            - --authenticationDatabase=admin
            - --eval
            - "db.adminCommand('ping')"
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 30
      
      # MongoDB Exporter for Prometheus monitoring
      - name: mongodb-exporter
        image: percona/mongodb_exporter:0.39
        ports:
        - containerPort: 9216
          name: metrics
        env:
        - name: MONGODB_URI
          value: "mongodb://$(MONGO_INITDB_ROOT_USERNAME):$(MONGO_INITDB_ROOT_PASSWORD)@localhost:27017/admin"
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: infra-mind-secrets
              key: MONGO_ROOT_USERNAME
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: infra-mind-secrets
              key: MONGO_ROOT_PASSWORD
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
        livenessProbe:
          httpGet:
            path: /metrics
            port: 9216
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /metrics
            port: 9216
          initialDelaySeconds: 5
          periodSeconds: 5
      
      volumes:
      - name: mongodb-storage
        persistentVolumeClaim:
          claimName: mongodb-pvc
      - name: mongodb-config
        configMap:
          name: mongodb-config
      - name: mongodb-init
        configMap:
          name: mongodb-init-scripts
      - name: mongodb-logs
        emptyDir: {}
      - name: mongodb-ssl
        secret:
          secretName: mongodb-ssl-certs
          optional: true

---
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
  namespace: infra-mind
  labels:
    app: mongodb
spec:
  selector:
    app: mongodb
  ports:
  - port: 27017
    targetPort: 27017
    protocol: TCP
  type: ClusterIP

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc
  namespace: infra-mind
  labels:
    app: mongodb
    component: database
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
  storageClassName: fast-ssd
  
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mongodb-config
  namespace: infra-mind
data:
  mongod.conf: |
    # Production MongoDB Configuration
    
    # Network settings
    net:
      port: 27017
      bindIp: 0.0.0.0
      maxIncomingConnections: 1000
      compression:
        compressors: snappy,zstd,zlib
    
    # Storage settings
    storage:
      dbPath: /data/db
      journal:
        enabled: true
        commitIntervalMs: 100
      wiredTiger:
        engineConfig:
          cacheSizeGB: 1
          journalCompressor: snappy
          directoryForIndexes: false
        collectionConfig:
          blockCompressor: snappy
        indexConfig:
          prefixCompression: true
    
    # Security settings
    security:
      authorization: enabled
      javascriptEnabled: false
    
    # Operational settings
    operationProfiling:
      slowOpThresholdMs: 100
      mode: slowOp
    
    # Logging settings
    systemLog:
      destination: file
      logAppend: true
      path: /var/log/mongodb/mongod.log
      component:
        accessControl:
          verbosity: 1
        command:
          verbosity: 1
        query:
          verbosity: 1
        write:
          verbosity: 1
    
    # Process management
    processManagement:
      fork: false
      pidFilePath: /var/run/mongodb/mongod.pid
    
    # Replication (for future replica set setup)
    # replication:
    #   replSetName: "rs0"
    
    # Sharding (for future sharding setup)
    # sharding:
    #   clusterRole: shardsvr

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mongodb-init-scripts
  namespace: infra-mind
data:
  init-mongo.js: |
    // Production MongoDB Initialization Script for Infra Mind
    print('Starting Infra Mind production database initialization...');
    
    // Switch to the application database
    db = db.getSiblingDB('infra_mind');
    
    // Create application user with appropriate permissions
    try {
      db.createUser({
        user: 'infra_mind_app',
        pwd: process.env.MONGO_APP_PASSWORD || 'change_this_password',
        roles: [
          { role: 'readWrite', db: 'infra_mind' },
          { role: 'dbAdmin', db: 'infra_mind' }
        ]
      });
      print('‚úÖ Application user created successfully');
    } catch (e) {
      print('‚ö†Ô∏è Application user may already exist: ' + e.message);
    }
    
    // === COLLECTION CREATION WITH VALIDATION ===
    
    // Users collection with comprehensive validation
    try {
      db.createCollection('users', {
        validator: {
          $jsonSchema: {
            bsonType: 'object',
            required: ['email', 'password_hash', 'created_at', 'is_active'],
            properties: {
              email: { 
                bsonType: 'string',
                pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'
              },
              password_hash: { bsonType: 'string', minLength: 60 },
              is_active: { bsonType: 'bool' },
              created_at: { bsonType: 'date' },
              last_login: { bsonType: 'date' },
              subscription_tier: { 
                enum: ['free', 'basic', 'premium', 'enterprise'] 
              },
              company_size: { 
                enum: ['startup', 'small', 'medium', 'large', 'enterprise'] 
              },
              industry: { bsonType: 'string' }
            }
          }
        },
        validationLevel: 'strict',
        validationAction: 'error'
      });
      print('‚úÖ Users collection created with validation');
    } catch (e) {
      print('‚ö†Ô∏è Users collection may already exist: ' + e.message);
    }
    
    // Assessments collection with validation
    try {
      db.createCollection('assessments', {
        validator: {
          $jsonSchema: {
            bsonType: 'object',
            required: ['user_id', 'status', 'created_at'],
            properties: {
              user_id: { bsonType: 'string' },
              status: { 
                enum: ['draft', 'pending', 'in_progress', 'completed', 'failed', 'cancelled'] 
              },
              priority: { 
                enum: ['low', 'medium', 'high', 'urgent'] 
              },
              created_at: { bsonType: 'date' },
              updated_at: { bsonType: 'date' },
              assessment_type: { 
                enum: ['infrastructure', 'security', 'compliance', 'cost_optimization'] 
              },
              business_requirements: { bsonType: 'object' },
              technical_requirements: { bsonType: 'object' }
            }
          }
        },
        validationLevel: 'strict',
        validationAction: 'error'
      });
      print('‚úÖ Assessments collection created with validation');
    } catch (e) {
      print('‚ö†Ô∏è Assessments collection may already exist: ' + e.message);
    }
    
    // Recommendations collection with validation
    try {
      db.createCollection('recommendations', {
        validator: {
          $jsonSchema: {
            bsonType: 'object',
            required: ['assessment_id', 'agent_name', 'confidence_score', 'created_at'],
            properties: {
              assessment_id: { bsonType: 'string' },
              agent_name: { bsonType: 'string' },
              confidence_score: { 
                bsonType: 'number',
                minimum: 0,
                maximum: 1
              },
              priority: { 
                enum: ['low', 'medium', 'high', 'critical'] 
              },
              category: { bsonType: 'string' },
              cloud_provider: { 
                enum: ['aws', 'azure', 'gcp', 'multi-cloud'] 
              },
              total_estimated_monthly_cost: { 
                bsonType: 'number',
                minimum: 0
              },
              business_impact: { 
                enum: ['low', 'medium', 'high', 'critical'] 
              },
              implementation_status: { 
                enum: ['not_started', 'in_progress', 'completed', 'rejected'] 
              },
              created_at: { bsonType: 'date' }
            }
          }
        },
        validationLevel: 'strict',
        validationAction: 'error'
      });
      print('‚úÖ Recommendations collection created with validation');
    } catch (e) {
      print('‚ö†Ô∏è Recommendations collection may already exist: ' + e.message);
    }
    
    // Reports collection with validation
    try {
      db.createCollection('reports', {
        validator: {
          $jsonSchema: {
            bsonType: 'object',
            required: ['assessment_id', 'user_id', 'report_type', 'status', 'created_at'],
            properties: {
              assessment_id: { bsonType: 'string' },
              user_id: { bsonType: 'string' },
              report_type: { 
                enum: ['executive_summary', 'technical_details', 'cost_analysis', 'compliance_report'] 
              },
              status: { 
                enum: ['generating', 'completed', 'failed', 'cancelled'] 
              },
              format: { 
                enum: ['pdf', 'html', 'json', 'markdown'] 
              },
              created_at: { bsonType: 'date' },
              generation_time_seconds: { 
                bsonType: 'number',
                minimum: 0
              },
              file_size_bytes: { 
                bsonType: 'number',
                minimum: 0
              }
            }
          }
        },
        validationLevel: 'strict',
        validationAction: 'error'
      });
      print('‚úÖ Reports collection created with validation');
    } catch (e) {
      print('‚ö†Ô∏è Reports collection may already exist: ' + e.message);
    }
    
    // Create other collections without strict validation for flexibility
    const collections = [
      'metrics',
      'agent_metrics', 
      'workflow_states',
      'web_research_data',
      'cache',
      'audit_logs',
      'backup_metadata',
      'health_checks'
    ];
    
    collections.forEach(function(collectionName) {
      try {
        db.createCollection(collectionName);
        print('‚úÖ ' + collectionName + ' collection created');
      } catch (e) {
        print('‚ö†Ô∏è ' + collectionName + ' collection may already exist: ' + e.message);
      }
    });
    
    // === PRODUCTION INDEXES CREATION ===
    print('Creating production-optimized indexes...');
    
    // User indexes
    db.users.createIndex({ 'email': 1 }, { unique: true, name: 'idx_users_email_unique' });
    db.users.createIndex({ 'is_active': 1, 'last_login': -1 }, { name: 'idx_users_active_login' });
    db.users.createIndex({ 'created_at': -1 }, { name: 'idx_users_created_desc' });
    db.users.createIndex({ 'company_size': 1, 'industry': 1 }, { name: 'idx_users_company_industry' });
    db.users.createIndex({ 'subscription_tier': 1, 'is_active': 1 }, { name: 'idx_users_subscription_active' });
    
    // Assessment indexes
    db.assessments.createIndex({ 'user_id': 1, 'status': 1 }, { name: 'idx_assessments_user_status' });
    db.assessments.createIndex({ 'user_id': 1, 'created_at': -1 }, { name: 'idx_assessments_user_created' });
    db.assessments.createIndex({ 'status': 1, 'priority': 1, 'created_at': -1 }, { name: 'idx_assessments_status_priority_created' });
    db.assessments.createIndex({ 'assessment_type': 1, 'status': 1 }, { name: 'idx_assessments_type_status' });
    db.assessments.createIndex({ 'tags': 1 }, { name: 'idx_assessments_tags' });
    
    // Recommendation indexes
    db.recommendations.createIndex({ 'assessment_id': 1, 'agent_name': 1 }, { name: 'idx_recommendations_assessment_agent' });
    db.recommendations.createIndex({ 'assessment_id': 1, 'confidence_score': -1 }, { name: 'idx_recommendations_assessment_confidence' });
    db.recommendations.createIndex({ 'confidence_score': -1, 'priority': 1 }, { name: 'idx_recommendations_confidence_priority' });
    db.recommendations.createIndex({ 'category': 1, 'priority': 1, 'created_at': -1 }, { name: 'idx_recommendations_category_priority_created' });
    db.recommendations.createIndex({ 'cloud_provider': 1, 'service_category': 1 }, { name: 'idx_recommendations_provider_service' });
    db.recommendations.createIndex({ 'total_estimated_monthly_cost': 1, 'confidence_score': -1 }, { name: 'idx_recommendations_cost_confidence' });
    
    // Report indexes
    db.reports.createIndex({ 'assessment_id': 1, 'report_type': 1 }, { name: 'idx_reports_assessment_type' });
    db.reports.createIndex({ 'user_id': 1, 'status': 1, 'created_at': -1 }, { name: 'idx_reports_user_status_created' });
    db.reports.createIndex({ 'status': 1, 'priority': 1 }, { name: 'idx_reports_status_priority' });
    db.reports.createIndex({ 'report_type': 1, 'format': 1, 'created_at': -1 }, { name: 'idx_reports_type_format_created' });
    
    // Metrics indexes with TTL
    db.metrics.createIndex({ 'metric_name': 1, 'timestamp': -1 }, { name: 'idx_metrics_name_timestamp' });
    db.metrics.createIndex({ 'metric_type': 1, 'timestamp': -1 }, { name: 'idx_metrics_type_timestamp' });
    db.metrics.createIndex({ 'source': 1, 'timestamp': -1 }, { name: 'idx_metrics_source_timestamp' });
    db.metrics.createIndex({ 'timestamp': 1 }, { expireAfterSeconds: 7776000, name: 'idx_metrics_ttl' }); // 90 days
    
    // Agent metrics indexes
    db.agent_metrics.createIndex({ 'agent_name': 1, 'completed_at': -1 }, { name: 'idx_agent_metrics_name_completed' });
    db.agent_metrics.createIndex({ 'assessment_id': 1, 'agent_name': 1 }, { name: 'idx_agent_metrics_assessment_agent' });
    db.agent_metrics.createIndex({ 'confidence_score': -1, 'agent_name': 1 }, { name: 'idx_agent_metrics_confidence_name' });
    db.agent_metrics.createIndex({ 'completed_at': 1 }, { expireAfterSeconds: 15552000, name: 'idx_agent_metrics_ttl' }); // 180 days
    
    // Workflow state indexes
    db.workflow_states.createIndex({ 'workflow_id': 1, 'assessment_id': 1 }, { name: 'idx_workflow_states_workflow_assessment' });
    db.workflow_states.createIndex({ 'assessment_id': 1, 'state': 1, 'updated_at': -1 }, { name: 'idx_workflow_states_assessment_state_updated' });
    db.workflow_states.createIndex({ 'state': 1, 'created_at': -1 }, { name: 'idx_workflow_states_state_created' });
    
    // Cache indexes with TTL
    db.cache.createIndex({ 'key': 1 }, { unique: true, name: 'idx_cache_key_unique' });
    db.cache.createIndex({ 'expires_at': 1 }, { expireAfterSeconds: 0, name: 'idx_cache_ttl' });
    db.cache.createIndex({ 'cache_type': 1, 'created_at': -1 }, { name: 'idx_cache_type_created' });
    
    // Audit log indexes with TTL
    db.audit_logs.createIndex({ 'user_id': 1, 'timestamp': -1 }, { name: 'idx_audit_logs_user_timestamp' });
    db.audit_logs.createIndex({ 'action': 1, 'timestamp': -1 }, { name: 'idx_audit_logs_action_timestamp' });
    db.audit_logs.createIndex({ 'timestamp': 1 }, { expireAfterSeconds: 31536000, name: 'idx_audit_logs_ttl' }); // 1 year
    
    // Backup metadata indexes
    db.backup_metadata.createIndex({ 'backup_date': -1 }, { name: 'idx_backup_metadata_date' });
    db.backup_metadata.createIndex({ 'backup_type': 1, 'status': 1 }, { name: 'idx_backup_metadata_type_status' });
    db.backup_metadata.createIndex({ 'backup_date': 1 }, { expireAfterSeconds: 31536000, name: 'idx_backup_metadata_ttl' }); // 1 year
    
    print('‚úÖ All production indexes created successfully');
    
    // === DATABASE CONFIGURATION ===
    
    // Set profiling for slow operations (production monitoring)
    db.setProfilingLevel(1, { slowms: 100 });
    print('‚úÖ Database profiling configured for operations > 100ms');
    
    // Create initial admin user if needed
    try {
      db.createUser({
        user: 'infra_mind_admin',
        pwd: process.env.MONGO_ADMIN_PASSWORD || 'change_this_admin_password',
        roles: [
          { role: 'dbOwner', db: 'infra_mind' },
          { role: 'userAdmin', db: 'infra_mind' }
        ]
      });
      print('‚úÖ Admin user created successfully');
    } catch (e) {
      print('‚ö†Ô∏è Admin user may already exist: ' + e.message);
    }
    
    // Insert initial configuration document
    try {
      db.system_config.insertOne({
        config_type: 'database_initialization',
        version: '1.0.0',
        initialized_at: new Date(),
        features: {
          validation: true,
          indexes: true,
          ttl_cleanup: true,
          profiling: true,
          users: true
        },
        collections_created: collections.length + 4, // +4 for validated collections
        indexes_created: 30 // Approximate count
      });
      print('‚úÖ System configuration document created');
    } catch (e) {
      print('‚ö†Ô∏è System configuration may already exist: ' + e.message);
    }
    
    print('üéâ Infra Mind production database initialization completed successfully!');
    print('üìä Database statistics:');
    print('   ‚Ä¢ Collections: ' + db.runCommand('listCollections').cursor.firstBatch.length);
    print('   ‚Ä¢ Users: ' + db.runCommand('usersInfo').users.length);
    print('   ‚Ä¢ Profiling level: ' + db.getProfilingLevel());
    print('   ‚Ä¢ Initialization completed at: ' + new Date().toISOString());